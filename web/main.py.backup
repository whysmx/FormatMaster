"""
Word Format Restorer - Web应用主程序
"""

from fastapi import FastAPI, UploadFile, File, Form, HTTPException, Response
from fastapi.responses import FileResponse, HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi import Request
from fastapi.responses import RedirectResponse
import os
import shutil
import aiofiles
import json
import uuid
from datetime import datetime
from pathlib import Path
from typing import List, Optional
import sys

# 添加父目录到路径以导入restorer模块
PARENT_DIR = Path(__file__).parent.parent
if str(PARENT_DIR) not in sys.path:
    sys.path.insert(0, str(PARENT_DIR))

from restorer.core import FormatRestorer
from restorer.comparer import FormatComparer

app = FastAPI(title="Word格式还原工具", version="1.0.0")

# 配置CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 挂载静态文件
app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/template_files", StaticFiles(directory="template_files"), name="template_files")

# 路径配置
DATA_DIR = Path("data")
TEMPLATE_FILES_DIR = Path("template_files")
UPLOADS_DIR = Path("static/uploads")
TEMPLATES_CONFIG = DATA_DIR / "templates.json"
HISTORY_CONFIG = DATA_DIR / "history.json"

# 确保目录存在
DATA_DIR.mkdir(exist_ok=True)
TEMPLATE_FILES_DIR.mkdir(exist_ok=True)
UPLOADS_DIR.mkdir(exist_ok=True)


# ==================== 数据模型 ====================

class Template:
    """模板数据模型"""

    def __init__(self, name: str, filename: str, is_default: bool = False):
        self.id = str(uuid.uuid4())
        self.name = name
        self.filename = filename
        self.is_default = is_default
        self.updated_at = datetime.now().isoformat()


# ==================== 工具函数 ====================

def load_templates() -> dict:
    """加载模板配置"""
    if TEMPLATES_CONFIG.exists():
        with open(TEMPLATES_CONFIG, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {"templates": []}


def save_templates(templates: dict):
    """保存模板配置"""
    with open(TEMPLATES_CONFIG, 'w', encoding='utf-8') as f:
        json.dump(templates, f, ensure_ascii=False, indent=2)


# ==================== 历史记录管理 ====================

def load_history() -> dict:
    """加载历史记录"""
    if HISTORY_CONFIG.exists():
        with open(HISTORY_CONFIG, 'r', encoding='utf-8') as f:
            return json.load(f)
    return {"conversions": []}


def save_history(history: dict):
    """保存历史记录"""
    with open(HISTORY_CONFIG, 'w', encoding='utf-8') as f:
        json.dump(history, f, ensure_ascii=False, indent=2)


def add_conversion_record(
            template_name=template["name"],
            original_filename=file.filename,
    template_name: str,
    original_filename: str,
    file_size: int,
    similarity: float,
    processing_time: float,
    status: str = "success"
):
    """添加转换记录"""
    history = load_history()

    record = {
        "id": str(uuid.uuid4()),
        "timestamp": datetime.now().isoformat(),
        "template_name": template_name,
        "file_size": file_size,
        "similarity": similarity,
        "processing_time": processing_time,
        "status": status
    }

    history["conversions"].insert(0, record)  # 最新的在最前面
    save_history(history)


def get_templates() -> List[dict]:
    """获取所有模板"""
    data = load_templates()
    return data.get("templates", [])


def get_default_template() -> Optional[dict]:
    """获取默认模板"""
    templates = get_templates()
    for template in templates:
        if template.get("is_default"):
            return template
    # 如果没有默认模板，返回第一个
    if templates:
        return templates[0]
    return None


# ==================== 页面路由 ====================

@app.get("/", response_class=HTMLResponse)
async def index():
    """首页 - 文档转换页面"""
    with open("templates/index.html", 'r', encoding='utf-8') as f:
        return f.read()


@app.get("/manage", response_class=HTMLResponse)
async def manage():
    """模板管理页面"""
    with open("templates/manage.html", 'r', encoding='utf-8') as f:
        return f.read()


# ==================== API路由 ====================

@app.get("/api/templates")
async def list_templates():
    """获取所有模板列表"""
    templates = get_templates()
    return {"success": True, "data": templates}


@app.post("/api/templates/upload")
async def upload_template(
    name: str = Form(...),
    file: UploadFile = File(...),
    is_default: bool = Form(False)
):
    """上传新模板"""
    # 验证文件类型
    if not file.filename.endswith('.docx'):
        raise HTTPException(status_code=400, detail="仅支持.docx文件")

    # 如果设置为默认，先取消其他模板的默认状态
    if is_default:
        data = load_templates()
        for template in data["templates"]:
            template["is_default"] = False
        save_templates(data)

    # 保存文件
    file_id = str(uuid.uuid4())
    filename = f"{file_id}_{file.filename}"
    file_path = TEMPLATE_FILES_DIR / filename

    try:
        contents = await file.read()
        async with aiofiles.open(file_path, 'wb') as f:
            await f.write(contents)

        # 保存到配置
        template = Template(name=name, filename=filename, is_default=is_default)
        data = load_templates()
        data["templates"].append({
            "id": template.id,
            "name": template.name,
            "filename": template.filename,
            "is_default": template.is_default,
            "updated_at": template.updated_at
        })
        save_templates(data)

        return {"success": True, "message": "模板上传成功", "data": {
            "id": template.id,
            "name": template.name
        }}
    except Exception as e:
        # 删除已上传的文件
        if file_path.exists():
            file_path.unlink()
        raise HTTPException(status_code=500, detail=f"上传失败: {str(e)}")


@app.delete("/api/templates/{template_id}")
async def delete_template(template_id: str):
    """删除模板"""
    data = load_templates()
    original_count = len(data["templates"])

    # 找到要删除的模板
    template_to_delete = None
    for template in data["templates"]:
        if template["id"] == template_id:
            template_to_delete = template
            break

    if not template_to_delete:
        raise HTTPException(status_code=404, detail="模板不存在")

    # 如果删除的是默认模板，设置第一个为默认
    if template_to_delete["is_default"]:
        remaining = [t for t in data["templates"] if t["id"] != template_id]
        if remaining:
            remaining[0]["is_default"] = True

    # 删除模板
    data["templates"] = [t for t in data["templates"] if t["id"] != template_id]
    save_templates(data)

    # 删除文件
    file_path = TEMPLATE_FILES_DIR / template_to_delete["filename"]
    if file_path.exists():
        file_path.unlink()

    return {"success": True, "message": "模板删除成功"}


@app.put("/api/templates/{template_id}/default")
async def set_default_template(template_id: str):
    """设置默认模板"""
    data = load_templates()

    # 取消所有模板的默认状态
    found = False
    for template in data["templates"]:
        if template["id"] == template_id:
            template["is_default"] = True
            found = True
        else:
            template["is_default"] = False

    if not found:
        raise HTTPException(status_code=404, detail="模板不存在")

    save_templates(data)
    return {"success": True, "message": "默认模板设置成功"}


@app.post("/api/convert")
async def convert_document(
    template_id: str = Form(...),
    file: UploadFile = File(...)
):
    """转换文档"""
    # 验证文件类型
    if not file.filename.endswith('.docx'):
        raise HTTPException(status_code=400, detail="仅支持.docx文件")

    # 获取模板
    templates = get_templates()
    template = None
    for t in templates:
        if t["id"] == template_id:
            template = t
            break

    if not template:
        raise HTTPException(status_code=404, detail="模板不存在")

    # 生成会话ID和文件路径
    session_id = str(uuid.uuid4())
    input_filename = f"{session_id}_{file.filename}"
    input_path = UPLOADS_DIR / input_filename

    # 保存上传的文件
    try:
        contents = await file.read()
        async with aiofiles.open(input_path, 'wb') as f:
            await f.write(contents)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"文件保存失败: {str(e)}")

    # 执行格式还原
    try:
        import time
        start_time = time.time()

        template_path = TEMPLATE_FILES_DIR / template["filename"]
        restorer = FormatRestorer(str(template_path))

        output_filename = file.filename.replace(".docx", "_已还原.docx")
        output_path = UPLOADS_DIR / f"{session_id}_{output_filename}"

        # 转换文档
        restorer.restore_format(str(input_path), str(output_path))

        # 计算处理时间
        processing_time = time.time() - start_time

        # 计算相似度（可选）
        comparer = FormatComparer()
        result = comparer.compare_documents(
            str(template_path),
            str(output_path),
            full_compare=False  # 仅对比格式文件
        )
        similarity = result.get("overall_similarity", 0.0)

        # 保存历史记录
        add_conversion_record(
            template_name=template["name"],
            original_filename=file.filename,
            template_name=template["name"],
            file_size=input_path.stat().st_size,
            similarity=similarity,
            processing_time=processing_time,
            status="success"
        )

        return {
            "success": True,
            "data": {
                "session_id": session_id,
                "output_filename": output_filename,
                "similarity": similarity,
                "download_url": f"/api/download/{session_id}/{output_filename}"
            }
        }
    except Exception as e:
        # 清理文件
        if input_path.exists():
            input_path.unlink()
        raise HTTPException(status_code=500, detail=f"转换失败: {str(e)}")


@app.get("/api/download/{session_id}/{filename}")
async def download_file(session_id: str, filename: str):
    """下载转换后的文件（下载后删除）"""
    file_path = UPLOADS_DIR / f"{session_id}_{filename}"

    if not file_path.exists():
        raise HTTPException(status_code=404, detail="文件不存在或已过期")

    # 读取文件内容
    async with aiofiles.open(file_path, 'rb') as f:
        content = await f.read()

    # 删除文件
    file_path.unlink()

    # 同时删除输入文件
    input_files = list(UPLOADS_DIR.glob(f"{session_id}_*.docx"))
    for f in input_files:
        f.unlink()

    # 返回文件（使用URL编码处理中文文件名）
    from urllib.parse import quote
    encoded_filename = quote(filename)
    return Response(
        content=content,
        media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        headers={
            "Content-Disposition": f"attachment; filename*=UTF-8''{encoded_filename}"
        }
    )


@app.get("/api/health")
async def health_check():
    """健康检查"""
    return {"success": True, "message": "服务正常"}


@app.get("/api/history")
async def get_history():
    """获取历史记录"""
    history = load_history()
    conversions = history.get("conversions", [])

    # 计算统计信息
    total_count = len(conversions)

    return {
        "success": True,
        "data": {
            "total_count": total_count,
            "conversions": conversions
        }
    }


@app.get("/history", response_class=HTMLResponse)
async def history_page():
    """历史记录页面"""
    with open("templates/history.html", 'r', encoding='utf-8') as f:
        return f.read()


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8002)
